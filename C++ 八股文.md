# C++ 八股文

# 一、多态、虚函数

**多态**：一个函数名具有多种状态，分为

- 编译时多态：通过重载和模板来实现
- 运行时多态：通过继承和虚函数实现

**虚函数的机制？**

虚函数主要用于 基类的指针或者引用指向派生类时，调用虚函数时，会根据指向的不同对象调用不同的函数。

具体通过**虚函数表**实现，存在全局区，每个有虚函数的类，在头部都有一个指针指向虚函数表(一个类一个虚函数表)，表中有所有虚函数的地址，当派生类中重写基类的虚函数时，相应派生类的虚函数表中的虚函数地址会改变，改成这个虚函数的地址。

**同时注意，对于存在虚函数的基类，其析构函数一定是虚函数；** 但是构造函数一定不能是虚函数，因为在创建对象时，需要去找虚函数表，但是对象还没创建，找不到虚表。



- **在(基类的)构造函数和析构函数中调用虚函数会怎么样？**

从语法上看，没有问题，但是无法达到目的。 因为在子类调用构造函数时，会优先调用父类的构造函数，然后父类构造函数期间，子类的特有成分还没有被初始化，此时若通过虚函数机制调用到子类的虚函数，一定会出错。 同时析构的时候，先对子类析构，然后进入父类，此时子类的成分已经销毁，无法实现虚函数。



- **构造函数和析构函数的异常问题，都不要抛出异常**

  构造函数遇到异常，不会调用析构函数，仅仅清理和释放内存，把异常抛出给程序员处理。

  析构函数遇到异常，异常之后的程序不会执行，会造成内存泄漏； 通常异常发生，c++机制会调用已构造对象的析构函数继续释放资源，如果还发生异常，就会造成崩溃。  所以可以新定义函数，在析构函数外面让用户调用，自己处理，如果自己没处理，析构函数就不抛出异常，直接停止。

  

- 虚函数的默认参数

  默认参数是静态绑定的，effective中的条例：绝不重新定义继承而来的默认参数值。

  



# 二、内存模型、继承

- **c++中类对象的内存布局是怎么样的?**

(1)、有虚函数的话，虚函数表的指针放在内存空间的头部

(2)、除虚函数之外，内存空间按照类的继承顺序(父类到子类)和字段的声明顺序布局

(3)、有多继承的话，会按照继承顺序布局，有虚函数的会存在虚函数指针然后加字段，如果多个父类都有虚函数，那么此时子类就会有多个虚函数表，每个分别对应一个父类，在linux下一般子类的字段会和父类合并(空间足够的话)，而windows下不会，所以在跨平台的时候也需要考虑到这个问题。 此外，子类重写父类的虚函数，会在相应的虚函数表中修改相应地址。

(4)、菱形继承，并采用虚继承的情况，排列顺序就是 各个父类的虚基类指针和字段，子类，公共基类的虚表指针和字段。在父类中，不存在公共基类的数据成员，只有一个虚基类指针指向公共基。

**菱形继承的问题：**两个父类会对公共基类的数据进行拷贝，不光造成数据空间的浪费，还造成了二义性。 可以通过虚继承的方式解决，两个父类分别虚继承自公共基类即可。





## **继承权限：**

1、子类的成员函数不受继承权限的影响，只能看到父类中的public和protected属性

2、子类的实例 受继承权限的影响，只能访问到父类中权限为public且继承权限也为public的属性和方法

友元函数不受权限的影响，只要声明了类外都能访问。







# 三、内存管理

## 1、C++的内存区域

- 堆，使用malloc或者free动态分配和释放内存，能分配比较大的内存，需要手动释放
- 栈，为函数的局部变量分配内存比较小的内存
- 全局、静态存储区，用于存储静态变量和全局变量
- 常量存储区，专门用来存放常量
- 自由存储区，使用new和delete分配和释放内存，具体实现可能是堆或者对象池(可通过重载new 运算符，在指定内存生成对象)。

## 2、堆和栈的区别

- 堆中的内存需要手动申请的释放，而栈是os自动
- 堆能申请的内存比较大(4G--32位机)，栈则只有1M
- 堆中分配和释放内存会产生内存碎片，栈不会
- 堆的分配效率低，地址从低向上，栈的分配效率高，地址由高向下

## 3、new和malloc，delete和free的区别

malloc和free是c的库函数，返回void*类型，new和delete是c++的，返回只能对象类型

new 分配内存无需执行大小，malloc需要执行大小

其实new和delete的底层实现也是用了malloc和free，在new的底层，先调用operator new来申请一片空间，然后利用placement new(原地构造函数)来实例化对象。而delete是调用了析构函数，然后free释放内存。

## 4、内存对齐

为了加快cpu在读取数据的效率问题，比如32位机上，每次读取32bit数据，也就是四个字节，对于一个结构体类型short和int布局，如果要读取int的话就需要读取两次，然后利用掩码位移等操作，才能得到想要的数，效率很低。字节对齐后，将以结构体中最长的基本变量作为长度单位，然后结构体变量的首地址，结构体内每个成员的相对起始地址的偏移量和结构体的总大小若不能被该长度整除，则填空对齐。 利用空间换时间的思路。

可以使用#pragma pack(n)改变对齐方式，指定对齐字节数。 项目的问题。

## 5、类型转换

1、const_cast

把const的属性去掉，即将const转换为非const，也可以反过来。 只能用于指针或者引用，并且只改变对象底层const，即指向常量的指针(const int * a)。

2、static_cast

用于各种隐式隐转换，可实现c++中所有基本类型的转换。 也可以用于类层次之间的向上转换(向下不安全)。 不能进行无关类型的转换，也不能用于底层const的转换。

3、dynamic_cast

将基类的指针或者引用安全的转化为派生类的指针或引用。 反过来也可以。 必须要有虚函数表，会根据虚函数标的-1地址处，存放一个类的层次关系，通过向上找(子类向父类找)，如果找到，就能转换成果，否则失败，返回NULL。

如果向下转换，会进行类型检查，是安全的，会判断基类指针是否指向派生类，然后做转换。 

场景：当我们想要使用某个基类的指针来执行某个派生类的操作，并且这个操作不是虚函数时

4、reinterptre_cast

几乎什么都能转，但只是重新解释了，实际上两个数据的比特位完全相同，尽量少用，不安全。



- **static cast 和 dynamic_cast的区别**

前者在编译器进行类型检查，后者在运行期执行类型检查。 后者需要有虚函数。 后者向下转换是安全的，会进行类型检查



# 四、智能指针

主要解决了内存泄漏的问题，自动释放内存，本身是一个类，内部含有一个指针引用计数，当多个shared_ptr指向同一个对象，引用计数cnt++，当智能指针对象析构时，cnt--，当cnt等于0，自动调用delete析构释放内存。

- shared_ptr,多个共享指针指向相同的对象，采用引用计数的机制，当最后一个对象销毁，自动释放内存
- unique_ptr,保证同一个时间只有一个智能指针指向该对象，
- weak_ptr 解决shared_ptr的循环引用问题， 对于一个链表，里面存在一个next指针，此时申请两个shared_ptr A和B，并让里面的next

相互指向对方，就会造成两个引用计数都是2，无法释放内存。  可以使用weak_ptr解决，是一种弱引用，不会增加引用计数，指向shared_ptr的对象，当shared_ptr对象被销毁，weak_ptr指向空，后续需要通过lock来判断能否调用weak_ptr.

此外，shared_ptr的引用计数本身是安全且无锁的，但是指向的对象的读写则不是，所以智能指针不是线程安全的。



# 五、各种关键字

## 1、static

1、当作用于文件域时，static变量或方法代表只有本文件可见，其他文件不可见，避免了重定义的问题

2、在一个类中，static描述了类方法和类属性，一个类只有一个，不属于某个对象。类属性改变所有的实例都改变。且需要在类外进行初始化。类方法只能访问类属性，否则报错，因为没有this指针(不属于某个对象)

3、当作用于函数作用域时，即在类中定义了某个静态变量，即使多次初始化，该变量也只会初始化一次，且只在该函数内可见。

4、对于文件域的静态变量和类属性需要在mian执行前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化。

## 2、const

1、const修饰的常量表示不可变，在类中修饰成员变量，表示不能修改类中的**非静态**成员属性，也不能调用非cosnt方法， 如果要修改该属性，可以把成员属性修改成mutable或者static

2、(顶层)指针常量指的时指针本身是个常量，不能修改这个地址，但能修改它指向的对象。 (底层)指向常量的指针，表示它指向的就是常量，不能被修改，但是指针本身可以修改。

3、const修饰的函数可以重载，const变量只能访问const方法，非const对象会优先对用非const方法，找不到才回去调用const方法。

const和static不能一起用，static没有this指针，但是const修饰的函数为了不让它修改里面的常量，会把this指针设置成const this

## 3、extern

在一个.cpp中定义了变量A，如果要在别的模块中，共用这个A，直接在要用的extern关键字，编译器遇到该变量或者函数，会去其他模块中寻找其定义

extern C， 让c++能够正确调用其他C语言代码，使得编译器使用C语言的方式进行编译。

## 4、explicit

表示类的构造函数是显示的，不能隐式转换

## 5、constexpr

告诉编译器某个函数或者变量在编译期就是一个常量，让编译期进行优化，加快效率。

## 5、volatile

告诉编译器这个变量是易变的，不要去优化它，每次使用都要从内存中去取。 

## 6、auto 和 decltype

都是实现类的自动推导，auto用于推导变量类型，decltype用于推导表达式类型，实际不会进行计算。

decltype可以用于根据对象的返回值，某个变量，或者某种运算来推算出具体的类型。

比如在模板中，实现两个类的相加，此时返回值使用dclytype推算

配合auto实现**返回值后置**， auto func(int a) -> declytype(a) {}

其是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题

## 7、内联函数和宏

1、内联函数是在编译的时候在函数调用处展开(不一定展开，编译器自己判断是否复杂，不复杂就展开，且虚函数也不会展开)， 宏在预处理的时候展开

2、内联函数的缺点是可能造成代码膨胀，只能用于比较短的函数，。 但是节省了函数调用的开销。

3、宏定义不会对类型进行检查，不方便调试，不直观。



# 六、左值右值

(1)、左值表示有常态，右值表示临时，简单的判断依据是 当代码移动到下一行，改值能否通过单一变量访问到。

(2)、左值引用使用&, 右值引用使用&&，其作用是生成移动构造，对于一个临时变量，会自动调用右值引用，从而避免了无效的拷贝，直接将值移动过去，并将临时变量的值置空，极大地增加了效率。

(3)、move可以将一个左值通过move变成右值，然后调用相应的移动构造，此后，这个左值将无法使用。  完美转发解决了 在一个函数中调用了右值引用，但在进入该函数后，右值引用变成了左值，可以通过forward实现完美转发，将传入的什么类型，传出什么类型。 在可变参模板中使用效果比较好。

- 自定义拷贝构造，深拷贝和浅拷贝

(1)、如果不自定义拷贝构造，就会调用系统的默认拷贝构造，对于成员变量含有指针的，就会直接将两个指针只想同一片内存，对于修改其中一个对象，另一个也会修改，就会出错。 这就是浅拷贝。  而实现拷贝构造就是要额外申请一片空间，将值拷贝过去，将新的对象指向申请的内存, 比如在实现vector的时候，需要实现拷贝构造， 申请一片空间，然后调用原地构造函数， 否则memcpy只会拷贝一次，指针的指针只会拷贝第一层。

- 移动构造和拷贝构造

移动构造传递的是一个右值引用，直接接管传递对象的内存， 并把移动的的源对象置空，拷贝构造重新分配内存并拷贝。 时间复杂度 是O(1) 和O(n).



# 七、工程问题

## 1、编译过程

从c++源文件到可执行文件的过程?

包括四个过程，**预处理，编译，汇编和链接**

1. 预处理：将#include文件复制到当前文件中，将#define进行替换， 将#ifndef 和#endif 来进行条件编译
2. 编译阶段，将代价进行词法，语法，语义分析，确认无误后将代码翻译成汇编语言
3. 汇编，将汇编语言转成机器语言，生成.obj文件
4. 链接，将obj文件中的函数声明和函数定义链接在一起

- 静态链接：生成可执行程序前，为每份程序拷贝一份函数的副本，占内存多，同时更新比较困难，一旦代码修改就需要重新编译链接。 但优点是执行速度快
- 动态链接：在运行时进行链接。 当多个程序用一个库文件，只需要指向同一个副本，同时更新只需要替换原目标文件。缺点是将连接的过程推迟到运行时，会有一定的效率影响。

## 2、vector手动释放内存

```c++
vector<int> nums;
方法一、nums = {}, 通过调用initializer_list构造对象，通过移动构造，清空元素，释放原对象
方法二、 nums.swap(vector<int>())
```

## 3、对象池思想

​		对于那些需要频繁创建和销毁的对象，对象池的思想是，首先从对象池中寻找有没有可用的对象，如果没有，就创建对象来使用，然后当一个对象不使用的时候，不是把它删除，而是将它设置为不激活的状态并放入对象池中，等待需要使用的时候再去对象池中寻找，并把它激活。

 

## 4、设计模式

### 1、单例模式

一些情况下，保证类的实例只有一个，通过get_instance方法唯一接口获取该实例对象。 且保证用户无法直接构造该类的实例，以及无法使用拷贝构造和赋值运算符。

分为懒汉式， 用到的时候才会加载，线程不安全

饿汉式，在main函数开始的时候创建对象，线程安全，但是no-local static对象在不同编译单元的初始化顺序未定义，可能存在返回一个未定义的实例。

在c++11之后，是一个meyers' singleton（懒汉式），利用了局部静态变量在第一次使用时才初始化的特性，并且c++11标准解决了loacl_static 的线程安全，成为最简洁且高效的实现方式。

```c++
class Singleton {
private:
    Singleton() {
        std::cout << "构造函数" << std::endl;
    };
    ~Singleton() {
        std::cout << "析构函数" << std::endl;
    };
public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
public:
    static Singleton& getInstance() {
        //返回local static的引用
        static Singleton instance;
        return instance;
    }
};
```

### 2、状态模式

游戏物体通常会因为玩家的输入或者某一事件从而从一种状态变成另一个状态，但是通过频繁创建ifelse会导致耦合，代码不易维护。

比较常用的是游戏的战斗系统，客户端把游戏动作发送给服务器，服务计算动作状态的结果，广播发送给客户端各种游戏状态，客户端接受状态，进行相应表现。

### 3、观察者模式

定义一个观察者，然后在被观察者里面添加一个观察者列表，通过管理链表来管理观察者，最后只需要访问链表来调用函数即可。 比如发送邮件事件。

### 4、工厂模式

用于分装和管理类的创建，终极目的是为了解耦，实现创建者和调用者的分离。

分为三种，简单工厂，一个工厂生产多种产品，指定产品的名字生成

普通工厂，将产品分配给多个工厂，每个工厂只生成一种产品

抽象工厂，将产品分配给多个工厂，每个工厂可以生产多中产品



## 5、函数调用

首先栈是从高地址向低地址存， 压入栈的顺序是反着压，这样对于数组的起始位置就是低地址，能够通过低地址+偏移量获取数据。  而如果初始地址是高地址，就要通过减偏移量，比如要获取a[0]，因为不知道数组长度就无法获取。

函数调用过程

- 反向依次压入参数
- 压入返回地址，压入ebp
- 移动ebp到esp处
- 将esp抬到新的栈帧

调用完成后，依次pop出来变量，然后ebp返回到原来的地址，返回地址出栈，执行到原来的地址。

如果通过栈溢出访问到并修改了返回地址，就会有被入侵的风险。

参数赋值的过程，先将参数移到寄存器中，然后把寄存器的值赋给相应的地址， 通过ebp - 8, -12来访问形参，然后返回值也会存放在寄存器内，最后存储在栈中，获取返回值。

参考: https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html

https://www.modb.pro/db/131185

![image-20220710162035371](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220710162035371.png)

接着就是执行函数内的操作，首先将变量赋值，比如var1 = param1, 先将变量push，然后通过param1的值赋给var

，后执行函数操作，然后返回，依次pop出变量，移动ebp和esp

![image-20220710162131478](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220710162131478.png)

# 八、C++11新特性

初始化链表

- 优点，增加了效率，在进入构造函数前，会先初始化声明的成员属性，调用其默认构造函数，而使用了初始化列表，就直接调用拷贝构造，且不易出错，如果一个对象没有默认构造， 如果不用初始化列表就出错。

auto和decltype

for each

nullptr

constexpr  告诉编译器某个函数返回一个常数值，可以用来在编译期初始化一些变量，能够优化运行的时间，比如计算一个x^3

左值右值

- 返回值优化，两种情况

  ```c++
  A func() {
  	return A();
  }  // 直接通过外面    A a = func()， 将a的地址传入，不调用拷贝构造
  
  A func() {
  	A a;
  	return a;
  }  //会调用拷贝构造，如果A中定义了移动构造，优先调用移动构造，否则调用拷贝构造
  
  ```

  

function,bind 和lambda表达式

- function可是使用的对象，包括函数指针，一个重载了括号运算符的类(仿函数，functor)，lambda表达式
- bind将可调用对象和参数一起绑定，用function接受。  或者将n元可调用的对象转成m元可调用对象，绑定一部分参数
- lambda定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用

智能指针



- emplace

  emplace_back和push_back的区别，c++11里面对于push_back会拷贝一份临时变量，然后在内存处构造对象。
  
  emplace_back直接在内存处构造对象，更快。
  
  c++20的push_back底层调用emplace_back， emplace_back将获取到的值根据左值右值，来调用同一个可变参模板，通过forward完美转发，最后底层都是通过原地构造+拷贝方式，对于左值调用拷贝构造，右值调用移动构造。
  
  但是emplace_back可以直接通过**传递参数**的方式，通过原地构造 + 参数构造方式，在对应的地址处直接构造对象，这样就连移动构造都不需要。
  
  ![image-20220808204852673](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220808204852673.png)

# 九、杂项



## 1、sizeof 和strlen的区别

- sizeof是一个操作符，编译期计算结果，strlen是个库函数，在运行期计算
- sizeof的参数是某个数据类型或者变量，strlen是以'\0'为结尾的字符串作为参数
- sizeof长度会将字符串结尾的\0计算进去，strlen不会。
- 对于转义字符包括普通转义字符，八进制和16进制，在字符串中会自动转成ascll表示的字符，比如八进制的101表示大写的A，\x41表示大写的A。

## 2、悬挂指针和野指针

- 悬浮指针    一般在delete或者free后没有将指针指向null，此时使用if (p != NULL)  也不会其效果，因为它指向任意地方，直接使用会出错
- 野指针  没有被初始化的指针，需要指向NULL

## 3、如何让一个类不能实例化

- 将类定义成抽象类(有纯虚函数)
- 将构造函数申明为private

## 4、空类的大小问题

sizeof(A) = 1, 为了区分不同类的实例对象，给了1字节的地址，可以使得空类的不同实例拥有独一无二的地址。

但是在继承的时候会进行优化，不会额外加上这1个字节。

含有static变量不会记录sizeof大小。

## 5、RTTI

又称运行时类型识别，包含typeid运算符，和dynamic_cast运算符

当无法使用虚函数，又要使用派生类中的某个操作。

比如判断两个继承关系的类是否相同，如果在基类使用虚函数equal判断，派生类重载虚函数，此时接受的形参一定是基类的引用或者指针，这样就只能使用基类的成员，无法比较派生类的（向下转换不安全）

但是，可以使用typeid判断两个对象类型是否一致，如果一致，调用虚函数就没有问题。

在基类的虚函数中，直接比较，在派生类中，使用dynamic_cast向下转换(已知肯定是安全的)，然后比较。



**RAII**

是c++的一种管理资源、避免内存泄漏的方式，在构造函数里申请资源，在析构函数时释放资源。



## 6、如何构造一个类，使其只能在堆上或者栈上分配空间

1、堆上分配，将析构函数声明为private

2、在栈上分配，重载operator new 和delete为private



## 7、内存泄漏的场景

1、malloc和free，new和delete没有成对出现， new []的对象 没有用delete[] 去释放。

2、类中未定义拷贝构造函数和赋值运算符，导致了对于包含指针的成员对象，在复制时会调用默认拷贝构造，从而使得两个指针指向同一片内存，在析构函数时会调用两次析构函数，并在第二次时报错。 同赋值运算赋，一定要先delete原来的存储空间，然后额外申请一片新的内存，调用构造函数。

3、没有将基类的析构函数定义为虚函数。



## 8、基于比较的排序算法时间复杂度nlogn

证明

```c++
n个节点，总共有n!种可能性，刚好对应一个满完全二叉树。
对应的树叶子节点n!,总结点个数是 2xn!-1, 树高是 log(2xn!-1) +1
可知 log(2xn!-1) + 1 >= logn!
1、计算上界
    logn! < logn^n = nlogn
2、计算下界
    logn! > log(n/2^(n/2)) = n/2 log(n/2)
所以 logn! 时间复杂度是O(nlogn)
```



## 9、一个空类默认有几个函数

6个，默认构造，拷贝构造，赋值运算符，析构函数， 取址运算符，const的取址运算符



## 10、影响类的大小

非静态成员属性， 虚函数，继承，内存对齐



## 11、override overload 和overwrite

override 覆盖，适用于多态，子类覆盖父类的虚函数，函数名和参数都要相同。

overload 重载，用于函数名相同，但是参数不同的情况，且const和非const类型

overwrite 重写，基类和派生类中函数名一致，参数也一致，但是通过派生类对象调用，只会调用到派生类中的函数，通过基类调用，只会调用到基类的函数。

# 

# STL八股文

## 1、迭代器

对于每个容器内部，都有一个迭代器，提供给外部一种遍历内部元素的方式，而又无需暴露容器内部的元素。

是一种指针对象

### 1、iterator_traits

目的：用来获取每个迭代器所指容器的特性，比如

- value type  (可以用来通过迭代器获取返回类型)

- difference type  (获取两个迭代器的距离)

- pointer type  

- reference type

- iterator category   (获取迭代器的类型)

  分为只读，只写，前向、双向，随机访问，**实现5个有继承关系的空类**

作用：可以根据迭代器的不同类型，执行不同的操作，已达到优化的目的。

例如：实现Advance函数，让一个迭代器移动n步，就可以萃取出相应的类型，然后通过第三个参数(类别)来找到相应的重载函数，将在编译期决定执行哪个函数，加快运行效率。 对于随机访问可以直接用 +=n， -=n 实现O(1)的访问速度，但是对于前向、后向迭代器却要On的时间复杂度。

要求：每个迭代器定义上面5种类型，然后iterator_traits需要对 指针、常量指针的偏特化处理。

### 2、type_traits 

目的： 负责萃取类别，用于判断这个类别是否是我们自己构造的类，比如是否包含默认构造，拷贝构造，赋值，默认析构函数，如果没有， 就代表是普通数据类型，比如int，char，这样我们在构造，拷贝，赋值时不需要调用构造函数，直接内存处理(malloc，free)，加快了效率。                                                                                          

实现两个空类，true_type和false_type。

利用偏特化技术，来指定某些类型(c++的内置类型)， 比如对于int就是true_type, 然后在实现初始化某个区间的值，利用重载，就可以直接调用赋值函数，但对于自定义类型，就需要调用构造函数，加快了效率。



### 3、迭代器失效

对于list和forward_list，其所有插入和删除前后的迭代器都有效

对于vector，string，在插入时，如果内存没有被重新配置，则插入位置前的迭代器有效，插入后的无效，如果重新配置，都无效；  再删除时，删除前的有效，删除后的无效。

对于deque，对于首尾以外的任何位置插入和删除会导致所有迭代器失效，如果对于首尾位置插入，迭代器失效，但是首尾位置删除，迭代器不受影响。



## 2、内存池

优点：

- 减少了malloc，直接从内存池中拿，提高了分配效率，
- 减少了申请小内存而造成的内存碎片问题
- 每次malloc都会带有cookie部分，用来记录此次申请的内存信息，通过内存池，一次申请较多的内存，进行管理，减少cookie，提高利用率。

做法：

1、采用了两级适配器，当申请的内存大于128字节时，直接调用malloc，反之调用二级适配器，从内存池中取，内存池的内存通过二级链表来管理。

2、每个内存池对应一个有16个指针的数组，分别管理8、16、24。。到128大小的内存块，在分配空间的时候，根据相应的大小找到相应的指针，然后去找该指针下有没有可用的空闲块，如果有，直接从头部拿一个，没有就去申请，一般要申请20 * size * 2的大小，把其中一半串成size * 20的单链表形式，存储在原来的空链表之下，另外的一半放在战备池中，下次需要申请就先去战备池看。 在归还的时候也找到相应的指针，使用头插法直接归还。

注意点： 

- 这里的指针使用了unoin结构，使得既可以指向下一个节点，也可以指向之际的内存区域，不会造8个字节的浪费。
- 当战备池中有数据，但是不够时，需要将战备池的数据挂到相应的free_list下，然后再去申请
- 当内存不够时，就会去找当前free_list中更大一个的指针，取一块拿来用

缺点是会产生一定的内部碎片，比如申请了120字节，会分配128字节。 但是减少了分配次数，性能更加高效。



## 3、容器

### 1、vector

- 底层是一个动态数组，包含三个迭代器，start，finish表示已存储的元素范围，end_of_storage是可用内存的最后一位。
- 内部的拷贝方式是深拷贝，需要额外申请一片空间，然后调用placement new来原地构造，拷贝数据。
- 数据的扩容方式是二倍扩容，当空间不够时，就会申请一片更大的空间(一般是2倍)，然后将原来的数据拷贝过去，接着释放原来的空。
- 释放和删除元素时，仅仅清空了里面的数据，对于pop_back这样的操作，仅仅是移动了finish指针， 对于vector的任何操作引起扩容，原本的迭代器就都是失效了

**reserve和resize的区别**

前者是将容量扩充到指定大小，当我们需要**频繁的push_back的时候，可能会调用很多次扩容操作，造成效率低下**，可以通过reserve一次性指定大小，当容量不足时，提前扩容，当capacity足够时，不发生改变。 本质是endofstorage改变

后者则是指定n和某个数值，当容器的大小size小于n，将会扩容，并将后续的值用指定值赋值，当size大于n，则会将多得都删除掉，并释放相应内存。本质是endofstorage和finish改变

- **二倍扩容均摊时间复杂度**

假设此时有n个元素插入，以2倍扩容的方式，总的操作次数是

1 + 2 + 4 + .... + n  约等于 2n，均摊每次push_back的时间复杂度是O(1)

- **为什么选择1.5倍或者两倍**

理想的扩容方式是1.5倍，因为希望第n次扩容能复用前n-1次释放的空间，比如申请了4，前面释放的空间 1 + 2 = 3，比原来更大一些，但是1.5倍却能达到这个效果。但在时间上，2倍的更优。

  当选择较大的倍率，会造成较大的空间浪费，当选择较小的倍率，会引发频繁的扩容，时间上不允许。

### 2、list

底层是一个双向链表，存在一个虚拟头结点，指向链表的头和尾，不连续的存储空间，适合大量插入和删除的操作。查找的时间复杂度O(n)，知道具体位置，插入删除的复杂度O(1),

插入返回指向插入节点的迭代器，删除指向删除元素的下一个元素迭代器。

链表内部的排序函数是通过空间换时间的归并思想， 维护一个64大小的指针数组，从0到63分别表示该指针最多能够存储2^i次， 每次从head上取出一个节点到carry指针上，然后i从0开始，依次将指针数组上的链表归并到carry上，类似于长度1和1归并得到2,2和2归并后得到4，直到该数组指针所指为空，或者达到最大的数组长度，将carry指针结果存到相应的数组指针上。  其实就是一个归并排序的逆过程，因为原归并排序需要每次遍历一边链表求长度，一分为二，再做归并，对于长链表而言，时间复杂度很高，但是这种排序利用了空间换时间的思想，每次从1开始，归并到2,4,8。。。

### 3、deque

底层是一个中控器，指针的指针，中控器的每一个节点都指向一个缓冲区，每片缓冲区中存储数据。

每片缓冲区是不连续的，但是可以通过迭代器来实现连续的效果，一个迭代器包括cur，first，last，node。

分别是指向当前缓冲区的某个值，当前缓冲区的头以及尾部，node表示指向当前缓冲区的中控区地址。在移动cur到first或者last的时候，表示移动到头了，需要从node找中控中相邻的缓冲区，如果满了，就需要扩容，扩容可以通过先判断中控是否往某一边倾斜很多，就调整到中间，如果数据满了，就申请另外一片更大的空间。

push_front和push_back都是O(1)的时间复杂度，适合在头部和尾部频繁插入删除的操作。

### 4、hashmap

STL的hashtable使用拉链法解决hash冲突，底层维护了一个vector，数组里存储了单链表节点node，每次存入一个key，value，通过hash函数，映射到相应的vector下标，通过头插法插入这个节点。 在查找的时候会遍历当前下标的所有节点，理论上冲突不多的时候，时间复杂度是常数级别的， 在选择vector的数量的时候，定义了若干个质数，因为质数会造成冲突的情况更少，当元素数量超过一定量时，会选择下一个质数重新建表，将所有元素重新插入过去。

### 5、map

- 红黑树的五个原则

  1、每个节点非黑即红

  2、根节点是黑

  3、叶子节点是黑(NIL节点)

  4、红色节点的孩子必须是黑

  5、从根节点到每个叶子节点的所有路径上，其黑色节点数量相同

插入的调整

插入的时候，按照BST的情况递归插入，回溯的时候调整每个节点即可。

1、插入的节点是红色节点，如果是黑必然会调整，但是红的话只有遇到红-红冲突才调整

2、站在祖父节点上

依次判断

- 如果没有红孩子，直接返回
- 如果有左右都是红孩子，且左右的孩子有红，进行红色上浮，将根节点边红，左右变成黑
- 如果左为红，且左没有红孩子，或者右为红且右没有红孩子，直接返回
- 如果左的左为红孩子(LL)，直接对根节点进行大右旋，然后交换新、旧根颜色， 如果左的右为红孩子(LR)，对左孩子进行大左旋，此时变成LL，然后一样操作。 对于RR，RL类似。

删除的调整

删除的时候，按照递归去删除，当找到删除的节点时，判断如果是度为1或者0，将其孩子节点代替该节点，并将其颜色+=删除的颜色， 如果删除是红色，无影响，如果删除是黑色，要将孩子节点变成双重黑。

如果度是2，则找到该节点的前驱，然后替换该节点，去其左孩子中递归删除前驱。



调整的时候，就是消除双重黑

站在父节点，依次判断

- 左孩子没有双重黑，直接返回

- 左孩子为双重黑，右孩子为黑且没有红孩子，直接左右孩子减去一重黑，然后根节点加一重黑；相反则类似

- 左孩子为双重黑，右孩子为黑，且有红孩子

  右的右孩子不为红，此时RL，对右孩子进行右旋，然后交换新旧跟的颜色，变成RR型。 

  右的右孩子为红，此时为RR，直接对根进行左旋，新的根节点变成旧得根节点颜色，左右变成黑。

  对于LL，LR类似

- 左孩子为双重黑，右孩子为红，此时进行左旋，然后交换新根和旧根的颜色，递归处理左孩子



-  红黑树的优点

 是一种弱AVL，解决了AVL树在插入和删处时会频繁调整树结构的缺点，适合频繁插入和删处的场景下。

- **map插入元素**

通过数组的方式，当存在相同key时也会直接覆盖

通过insert函数和pair键值对，或者makepair函数，此时如果存在相同key就会返回插入失败，不会覆盖。



- **hashmap和map的区别：**

1、在查询效率上，map的平均查询时间是logn,  hashmap查询理论是O1，常数级，但是偶尔会达到On，所以并不稳定，如果场景是查询次数比较多，求整体效率，优先hashmap，如果查询次数少，考虑map，不会产生不稳定的情况。

2、在内存使用上，hashmap占用内存更多。



- map和set插入和删除的效率比其他序列容器高

  因为底层是红黑树，插入删除的是节点，时间复杂度O(logn)，不需要内存拷贝和内存移动。



# 

# 其它

## 1、Cache

(1)、俗称高速缓冲存储器，因为cpu的运行速度很快，但是访问内存的速度很慢，因此加一个Cache，能够先从Cache里读数据，缩短获取数据的时间。

(2)、利用了程序的局部性原理，在遍历数组时按照内存顺序访问，充分利用cpu预测分支的功能，将预测的指令放到缓存中，此外缓存的容量和块长是影响效率的重要因素。

- 如何保证缓存一致性？

在多核cpu中，每个核都有自己的缓存，在两个核进行独自修改缓存中的数据时，就有可能造成数据不一致。

解决办法是采用cache一致性协议，对主线加锁等

- 一个缓存块的大小

  如果缓存没有命中，不仅需要把该字从主存中取出，还要从主存中将它所在的整个字块调入内存，Cache line的大小是64B



## 2、C++问题

1、vector的数组为空时，使用for循环， i < arr.size() - 1, 此时会进入循环

原因是size返回是size_t，无符号类型， -1的补码是  0x ffff ffff ffff ffff ,  转化为无符号正数就是 2^64 - 1, 可以先把值转成int

同样也需要注意就是，for循环，使用无符号整形  --， 一直到 >= 0，会死循环

2、返回局部变量的指针

不推荐这种做法，原本的栈空间的可能被重写入，造成**未定义**的情况。

但是有时候是可以得到想要的值的，在栈没有被重写入时
函数的调用过程，是反向压入函数参数，压入函数返回地址，压入ebp指针，抬高ebp到esp，提高esp， 开始局部变量压入，执行操作

调用完之后esp降到ebp，弹出ebp，弹出返回地址并执行。

此时其实时可以访问到 调用函数的局部变量的，但是如果我再往栈里压入，就会覆盖掉。

一般来说，推荐直接传地址进入操作， 或者直接返回某个变量， 对于某个类来说，返回的操作跟内部的拷贝构造函数有关，如果定义了右值拷贝，优先调用右值拷贝，如果没有就调用左值拷贝。



3、迭代器失效的问题

使用erase后，一般会返回下一个有效地迭代器，所以在通过迭代器遍历容器时，如果删除某几个元素，此时一定要迭代器接受erase返回的迭代器，否则原本的迭代器失效。

4、链表的排序

使用list.sort ，而不能使用sort